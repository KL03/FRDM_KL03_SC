###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        25/Jan/2016  11:46:46
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\src\cpu\arm_cm0.c
#    Command line =  
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\src\cpu\arm_cm0.c
#        -D IAR -D FREEDOM -lCN
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\FLASH_32KB\List\
#        -o
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\FLASH_32KB\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\projects\platinum\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\common\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\cpu\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\cpu\headers\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\lptmr\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\mcg\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\pmc\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\rcm\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\smc\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\uart\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\wdog\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\cmp\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\platforms\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\
#        --cpu_mode thumb -Ol --use_c++_inline
#    List file    =  
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\FLASH_32KB\List\arm_cm0.lst
#    Object file  =  
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\FLASH_32KB\Obj\arm_cm0.o
#
###############################################################################

C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\src\cpu\arm_cm0.c
      1          /*
      2           * File:		arm_cm4.c
      3           * Purpose:		Generic high-level routines for ARM Cortex M4 processors
      4           *
      5           * Notes:
      6           */
      7          
      8          #include "common.h"
      9          
     10          /***********************************************************************/
     11          /*
     12           * Configures the ARM system control register for STOP (deep sleep) mode
     13           * and then executes the WFI instruction to enter the mode.
     14           *
     15           * Parameters:
     16           * none
     17           *
     18           * Note: Might want to change this later to allow for passing in a parameter
     19           *       to optionally set the sleep on exit bit.
     20           */
     21          
     22          void stop (void)
     23          {
     24          	/* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
     25          	SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
     26          
     27          	/* WFI instruction will start entry into STOP mode */
     28          #ifndef KEIL
     29          	asm("WFI");
     30          #else
     31          	__wfi();
     32          #endif
     33          }
     34          /***********************************************************************/
     35          /*
     36           * Configures the ARM system control register for WAIT (sleep) mode
     37           * and then executes the WFI instruction to enter the mode.
     38           *
     39           * Parameters:
     40           * none
     41           *
     42           * Note: Might want to change this later to allow for passing in a parameter
     43           *       to optionally set the sleep on exit bit.
     44           */
     45          
     46          void wait (void)
     47          {
     48          	/* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
     49          	 * of deep sleep.
     50          	 */
     51          	SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;	
     52          
     53          	/* WFI instruction will start entry into WAIT mode */
     54          #ifndef KEIL
     55          	asm("WFI");
     56          #else
     57              __wfi();
     58          #endif
     59          }
     60          /***********************************************************************/
     61          /*
     62           * Change the value of the vector table offset register to the specified value.
     63           *
     64           * Parameters:
     65           * vtor     new value to write to the VTOR
     66           */
     67          
     68          void write_vtor (int vtor)
     69          {
     70                  /* Write the VTOR with the new value */
     71                  SCB_VTOR = vtor;	
     72          }
     73          /***********************************************************************/
     74          /*
     75           * Initialize the NVIC to enable the specified IRQ.
     76           * 
     77           * NOTE: The function only initializes the NVIC to enable a single IRQ. 
     78           * Interrupts will also need to be enabled in the ARM core. This can be 
     79           * done using the EnableInterrupts macro.
     80           *
     81           * Parameters:
     82           * irq    irq number to be enabled (the irq number NOT the vector number)
     83           */
     84          
     85          void enable_irq (int irq)
     86          {   
     87              /* Make sure that the IRQ is an allowable number. Up to 48 is 
     88               * used.
     89               */
     90              if (irq > 32)
     91                  printf("\nERR! Invalid IRQ value passed to enable irq function!\n");
     92              else
     93              {
     94                /* Determine which of the NVICISERs corresponds to the irq */
     95                NVIC_ICPR |= 1 << (irq%32);
     96                NVIC_ISER |= 1 << (irq%32);
     97              }
     98          }
     99          /***********************************************************************/
    100          /*
    101           * Initialize the NVIC to disable the specified IRQ.
    102           * 
    103           * NOTE: The function only initializes the NVIC to disable a single IRQ. 
    104           * If you want to disable all interrupts, then use the DisableInterrupts
    105           * macro instead. 
    106           *
    107           * Parameters:
    108           * irq    irq number to be disabled (the irq number NOT the vector number)
    109           */
    110          
    111          void disable_irq (int irq)
    112          {
    113              
    114              /* Make sure that the IRQ is an allowable number. Right now up to 48 is 
    115               * used.
    116               */
    117              if (irq > 32)
    118                  printf("\nERR! Invalid IRQ value passed to disable irq function!\n");
    119              else
    120                /* Determine which of the NVICICERs corresponds to the irq */
    121                NVIC_ICER = 1 << (irq%32);
    122          }
    123          /***********************************************************************/
    124          /*
    125           * Initialize the NVIC to set specified IRQ priority.
    126           * 
    127           * NOTE: The function only initializes the NVIC to set a single IRQ priority. 
    128           * Interrupts will also need to be enabled in the ARM core. This can be 
    129           * done using the EnableInterrupts macro.
    130           *
    131           * Parameters:
    132           * irq    irq number to be enabled (the irq number NOT the vector number)
    133           * prio   irq priority. 0-3 levels. 0 max priority
    134           */
    135          
    136          void set_irq_priority (int irq, int prio)
    137          {   
    138              /*irq priority pointer*/
    139              uint8 *prio_reg;
    140              uint8 err = 0;
    141              uint8 div = 0;
    142              
    143              /* Make sure that the IRQ is an allowable number. Right now up to 32 is 
    144               * used.
    145               *
    146               * NOTE: If you are using the interrupt definitions from the header
    147               * file, you MUST SUBTRACT 16!!!
    148               */
    149              if (irq > 32)
    150              {
    151                  printf("\nERR! Invalid IRQ value passed to priority irq function!\n");
    152                  err = 1;
    153              }
    154          
    155              if (prio > 3)
    156              {
    157                  printf("\nERR! Invalid priority value passed to priority irq function!\n");
    158                  err = 1;
    159              }
    160              
    161              if (err != 1)
    162              {
    163                  /* Determine which of the NVICIPx corresponds to the irq */
    164                  div = irq / 4;
    165                  prio_reg = (uint8 *)((uint32)&NVIC_IP(div));
    166                  /* Assign priority to IRQ */
    167                  *prio_reg = ( (prio&0x3) << (8 - ARM_INTERRUPT_LEVEL_BITS) );             
    168              }
    169          }          
    170          
    171          /***********************************************************************/
    172          

Errors: 2
Warnings: none
