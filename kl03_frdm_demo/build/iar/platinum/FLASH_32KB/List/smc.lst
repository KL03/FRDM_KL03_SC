###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        25/Jan/2016  11:46:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\src\drivers\smc\smc.c
#    Command line =  
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\src\drivers\smc\smc.c
#        -D IAR -D FREEDOM -lCN
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\FLASH_32KB\List\
#        -o
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\FLASH_32KB\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\projects\platinum\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\common\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\cpu\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\cpu\headers\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\lptmr\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\mcg\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\pmc\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\rcm\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\smc\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\uart\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\wdog\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\drivers\cmp\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\..\..\src\platforms\
#        -I
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\..\
#        --cpu_mode thumb -Ol --use_c++_inline
#    List file    =  
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\FLASH_32KB\List\smc.lst
#    Object file  =  
#        C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\build\iar\platinum\FLASH_32KB\Obj\smc.o
#
###############################################################################

C:\Users\B55335\Desktop\github\FRDM_KL03_SC\kl03_frdm_demo\src\drivers\smc\smc.c
      1          /*
      2           * File:        smc.c
      3           * Purpose:     Provides routines for entering low power modes.
      4           *
      5           * Notes:	Since the wakeup mechanism for low power modes
      6           *              will be application specific, these routines
      7           *              do not include code to setup interrupts to exit
      8           *              from the low power modes. The desired means of
      9           *              low power mode exit should be configured before
     10           *              calling any of these functions.
     11           *
     12           *              These routines do not include protection to
     13           *              prevent illegal state transitions in the mode
     14           *              controller, and all routines that write to the
     15           *              PMPROT register write a value to allow all
     16           *              possible low power modes (it is write once, so
     17           *              if only the currently requested mode is enabled
     18           *              a different mode couldn't be enabled later on).
     19           *              
     20           */
     21          
     22          #include "common.h"
     23          #include "smc.h"
     24          
     25          /***************************************************************/
     26          /*
     27           * Configures the ARM system control register for WAIT(sleep)mode
     28           * and then executes the WFI instruction to enter the mode.
     29           *
     30           * Parameters:
     31           * none
     32           *
     33           */
     34          
     35          void sleep (void)
     36          {
     37          /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) 
     38           * mode instead of deep sleep.
     39           */
     40          SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
     41          
     42          #ifdef CMSIS
     43            __wfi();
     44          #else
     45            /* WFI instruction will start entry into WAIT mode */
     46            asm("WFI");
     47          #endif 
     48          }
     49          /***************************************************************/
     50          /*
     51           * Configures the ARM system control register for STOP  
     52           * (deepsleep) mode and then executes the WFI instruction 
     53           * to enter the mode.
     54           *
     55           * Parameters:
     56           * none
     57           *
     58           */
     59          
     60          void deepsleep (void)
     61          {
     62            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
     63            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
     64          
     65          #ifdef CMSIS
     66            __wfi();
     67          #else
     68            /* WFI instruction will start entry into STOP mode */
     69            asm("WFI");
     70          #endif
     71          }
     72          /********************************************************************/
     73          /* WAIT mode entry routine. Puts the processor into wait mode.
     74           * In this mode the core clock is disabled (no code executing), but 
     75           * bus clocks are enabled (peripheral modules are operational). 
     76           *
     77           * Mode transitions:
     78           * RUN -> WAIT
     79           * VLPR -> VLPW
     80           *
     81           * This function can be used to enter normal wait mode or VLPW
     82           * mode. If you are executing in normal run mode when calling this
     83           * function, then you will enter normal wait mode. If you are in VLPR
     84           * mode when calling this function, then you will enter VLPW mode instead.
     85           *
     86           * NOTE: Some modules include a programmable option to disable them in 
     87           * wait mode. If those modules are programmed to disable in wait mode, 
     88           * they will not be able to generate interrupts to wake up the core.
     89           *
     90           * WAIT mode is exited using any enabled interrupt or RESET, so no
     91           * exit_wait routine is needed. 
     92           * 
     93           * 
     94           * Parameters:
     95           * none
     96           */
     97          void enter_wait(void)
     98          {
     99          #ifdef CMSIS
    100              /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
    101               * of deep sleep.
    102               */
    103          	SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
    104                  
    105              __wfi();
    106          #else
    107              wait();
    108          #endif
    109          }
    110          /********************************************************************/
    111          /* STOP mode entry routine. Puts the processor into normal stop mode.
    112           * In this mode core, bus and peripheral clocks are disabled.
    113           *
    114           * Mode transitions:
    115           * RUN -> STOP
    116           *
    117           * This function can be used to enter normal stop mode. 
    118           * If you are executing in normal run mode when calling this
    119           * function and AVLP = 0, then you will enter normal stop mode. 
    120           * If AVLP = 1 with previous write to PMPROT
    121           * then you will enter VLPS mode instead.
    122           *
    123           * STOP mode is exited using any enabled interrupt or RESET, so no
    124           * exit_stop routine is needed.
    125           *
    126           * Parameters:
    127           * Partial Stop Option:  
    128           *  0x00 = STOP - Normal Stop Mode
    129           *  0x40 = PSTOP1 - Partial Stop with both system and bus clocks disabled
    130           *  0x80 = PSTOP2 - Partial Stop with system clock disabled and bus clock enabled
    131           *  0xC0 = Reserved
    132           */
    133          void enter_stop(unsigned char partial_stop_opt)
    134          {
    135            /* The PMPROT register may have already been written by init code
    136               If so then this next write is not done since  
    137               PMPROT is write once after RESET  
    138               this write-once bit allows the MCU to enter the
    139               normal STOP mode.
    140               If AVLP is already a 1, VLPS mode is entered instead of normal STOP*/
    141            SMC_PMPROT = 0;  
    142          
    143            /* Set the STOPM field to 0b000 for normal STOP mode */
    144            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
    145            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0); 
    146            SMC_STOPCTRL &= ~SMC_STOPCTRL_PSTOPO_MASK;
    147            SMC_STOPCTRL |= partial_stop_opt;
    148            /*wait for write to complete to SMC before stopping core */  
    149            partial_stop_opt = SMC_PMCTRL;
    150            
    151          #ifdef CMSIS
    152            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    153            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    154            __wfi();
    155          #else
    156            stop();
    157          #endif
    158          }
    159          /****************************************************************/
    160          /* VLPR mode entry routine.Puts the processor into very low power
    161           * run mode. In this mode all clocks are enabled, but the core clock limited. 
    162           * The flash clock is limited to 1MHz or less. 
    163           *
    164           * Mode transitions:
    165           * RUN -> VLPR
    166           *
    167           * exit_vlpr() function can be used 
    168           * to switch from VLPR back to RUN. 
    169           * 
    170           * while in VLPR,VLPW or VLPS the exit to VLPR is not possible  
    171           *
    172           *
    173           * Parameters:
    174           * Return value : PMSTAT value or error code
    175           *                PMSTAT = return_value = PMSTAT
    176           *                         000_0001 Current power mode is RUN
    177           *                         000_0100 Current power mode is VLPR
    178           *                ERROR Code =  0x14 - already in VLPR mode
    179           *                           =  0x24 - REGONS never clear indicating stop regulation
    180           */
    181          int enter_vlpr(void)
    182          {
    183            int i; 
    184            unsigned int return_value;
    185            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
    186                   return_value = 0x14;
    187                   }
    188            /* The PMPROT register may have already been written by init code
    189               If so then this next write is not done.  
    190               PMPROT is write once after RESET  
    191               this write-once bit allows the MCU to enter the
    192               very low power modes: VLPR, VLPW, and VLPS   */
    193            SMC_PMPROT = SMC_PMPROT_AVLP_MASK;  
    194              
    195            /* Set the (for MC1)LPLLSM or (for MC2)STOPM field 
    196               to 0b010 for VLPS mode -
    197               and RUNM bits to 0b010 for VLPR mode  */
    198            SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK; 
    199            SMC_PMCTRL  |= SMC_PMCTRL_RUNM(0x2);
    200            /* Wait for VLPS regulator mode to be confirmed */
    201            for (i = 0 ; i < 10000 ; i++)
    202              {     /* check that the value of REGONS bit is not 0
    203                       once it is a zero we can stop checking */
    204                if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) ==0x04){
    205                 /* 0 Regulator is in stop regulation or in transition 
    206                      to/from it
    207                    1 MCU is in Run regulation mode */
    208                }  
    209                else  break;
    210              }  
    211            if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) ==0x04) 
    212              {  
    213                return_value = 0x24; 
    214              }
    215            /* SMC_PMSTAT register only exist in Mode Controller 2 MCU versions */
    216            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK) == 4)  
    217              {
    218                return_value = SMC_PMSTAT;
    219              }
    220            return (return_value);
    221          }
    222          /********************************************************************/
    223          /* VLPR mode exit routine. Puts the processor into normal run mode
    224           * from VLPR mode. You can transition from VLPR to normal run using
    225           * this function.
    226           *
    227           * Mode transitions:
    228           * VLPR -> RUN
    229           *
    230           * Parameters:
    231           * none
    232           */
    233           /********************************************************************/
    234          
    235          void exit_vlpr(void)
    236          {
    237              int i;
    238              /* check to make sure in VLPR before exiting    */
    239              if  ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4) {
    240                
    241                 /* Clear RUNM */
    242                 SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;
    243                                
    244                 /* Wait for normal RUN regulation mode to be confirmed */                   
    245                 // 1 PMSTAT MCU is in RUN  mode
    246                 // 4 PMSTAT MCU is in VLPR mode
    247                 for (i=0;i<0xff;i++)
    248                 {
    249                     if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
    250                       if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) == 1)
    251              	        break;
    252                 }           
    253              }  //if in VLPR mode
    254               // else if not in VLPR ignore call
    255          }
    256          /***************************************************************/
    257          /* VLPS mode entry routine. Puts the processor into VLPS mode 
    258           * directly from run or VLPR modes. 
    259           *
    260           * Mode transitions:
    261           * RUN  -> VLPS
    262           * VLPR -> VLPS
    263           *
    264           * Note, when VLPS is entered directly from RUN or VLPR mode, 
    265           * exit to VLPR is disabled by hardware and the system will
    266           * always exit back to RUN.
    267           *
    268           * Parameters:  
    269           * none
    270           */
    271           /****************************************************************/
    272          
    273          void enter_vlps(void)
    274          {
    275            volatile unsigned int dummyread;
    276            /* The PMPROT register may have already been written by init code
    277               If so then this next write is not done since  
    278               PMPROT is write once after RESET 
    279               allows the MCU to enter the VLPR, VLPW, and VLPS modes.
    280               If AVLP is already writen to 0 
    281               Stop is entered instead of VLPS*/
    282            SMC_PMPROT = SMC_PMPROT_AVLP_MASK;           
    283            /* Set the STOPM field to 0b010 for VLPS mode */
    284            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
    285            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x2); 
    286            /*wait for write to complete to SMC before stopping core */  
    287            dummyread = SMC_PMCTRL;
    288            dummyread++;
    289            /* Now execute the stop instruction to go into VLPS */
    290            #ifdef CMSIS
    291            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    292            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    293            __wfi();
    294          #else
    295            stop();
    296          #endif
    297          }
    298          /****************************************************************/
    299          /* LLS mode entry routine. Puts the processor into LLS mode from
    300           * normal run mode or VLPR. 
    301           *
    302           * Mode transitions:
    303           * RUN -> LLS
    304           * VLPR -> LLS
    305           *
    306           * NOTE: LLS mode will always exit to RUN mode even if you were 
    307           * in VLPR mode before entering LLS.
    308           *
    309           * Wakeup from LLS mode is controlled by the LLWU module. Most
    310           * modules cannot issue a wakeup interrupt in LLS mode, so make
    311           * sure to setup the desired wakeup sources in the LLWU before 
    312           * calling this function.
    313           *
    314           * Parameters:
    315           * none
    316           */
    317           /********************************************************************/
    318          
    319          
    320          /***** No LLS mode in KL02 ******/
    321          
    322          //void enter_lls(void)
    323          //{
    324          //   volatile unsigned int dummyread;
    325          //   /* Write to PMPROT to allow LLS power modes this write-once 
    326          //      bit allows the MCU to enter the LLS low power mode*/
    327          //   SMC_PMPROT = SMC_PMPROT_ALLS_MASK;   
    328          //   /* Set the STOPM field to 0b011 for LLS mode  */
    329          //   SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
    330          //   SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x3); 
    331          //   /*wait for write to complete to SMC before stopping core */  
    332          //   dummyread = SMC_PMCTRL;
    333          //   dummyread++;
    334          //   /* Now execute the stop instruction to go into LLS */
    335          //   #ifdef CMSIS
    336          //   /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    337          //   SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    338          //   __wfi();
    339          // #else
    340          //   stop();
    341          // #endif
    342          // }
    343          /***************************************************************/
    344          /* VLLS3 mode entry routine. Puts the processor into 
    345           * VLLS3 mode from normal run mode or VLPR. 
    346           *
    347           * Mode transitions:
    348           * RUN -> VLLS3
    349           * VLPR -> VLLS3
    350           *
    351           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    352           * in VLPR mode before entering VLLSx.
    353           *
    354           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    355           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    356           * sure to setup the desired wakeup sources in the LLWU before 
    357           * calling this function.
    358           *
    359           * Parameters:
    360           * none  
    361           */
    362           /********************************************************************/
    363          
    364          void enter_vlls3(void)
    365          {
    366            volatile unsigned int dummyread;
    367            /* Write to PMPROT to allow VLLS3 power modes */
    368            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;      
    369            /* Set the STOPM field to 0b100 for VLLS3 mode */
    370            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
    371            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
    372            /* set VLLSM = 0b11 */
    373            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(3);          
    374            /*wait for write to complete to SMC before stopping core */  
    375            dummyread = SMC_STOPCTRL;
    376            dummyread++;
    377            /* Now execute the stop instruction to go into VLLS3 */
    378            #ifdef CMSIS
    379            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    380            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    381            __wfi();
    382          #else
    383            stop();
    384          #endif
    385          }
    386          /***************************************************************/
    387          /* VLLS2 mode entry routine. Puts the processor into 
    388           * VLLS2 mode from normal run mode or VLPR. 
    389           *
    390           * Mode transitions:
    391           * RUN -> VLLS2
    392           * VLPR -> VLLS2
    393           *
    394           * NOTE: VLLSx modes will always exit to RUN mode even  
    395           *       if you werein VLPR mode before entering VLLSx.
    396           *
    397           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    398           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    399           * sure to setup the desired wakeup sources in the LLWU before 
    400           * calling this function.
    401           *
    402           * Parameters:
    403           * none  
    404           */
    405           /********************************************************************/
    406          
    407          void enter_vlls2(void)
    408          {
    409            volatile unsigned int dummyread;
    410            /* Write to PMPROT to allow VLLS2 power modes */
    411            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;      
    412            /* Set the STOPM field to 0b100 for VLLS2 mode */
    413            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
    414            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
    415            /* set VLLSM = 0b10 */
    416            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(2);                
    417            /*wait for write to complete to SMC before stopping core */  
    418            dummyread = SMC_STOPCTRL;
    419            dummyread++;
    420            /* Now execute the stop instruction to go into VLLS2 */
    421            #ifdef CMSIS
    422            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    423            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    424            __wfi();
    425          #else
    426            stop();
    427          #endif
    428          }
    429          /***************************************************************/
    430          /* VLLS1 mode entry routine. Puts the processor into 
    431           * VLLS1 mode from normal run mode or VLPR. 
    432           *
    433           * Mode transitions:
    434           * RUN -> VLLS1
    435           * VLPR -> VLLS1
    436           *
    437           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    438           * in VLPR mode before entering VLLSx.
    439           *
    440           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    441           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    442           * sure to setup the desired wakeup sources in the LLWU before 
    443           * calling this function.
    444           *
    445           * Parameters:
    446           * none  
    447           */
    448           /********************************************************************/
    449          
    450          void enter_vlls1(void)
    451          {
    452            volatile unsigned int dummyread;
    453            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
    454              
    455            /* Write to PMPROT to allow all possible power modes */
    456            /* Set the STOPM field to 0b100 for VLLS1 mode */
    457            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
    458            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
    459            /* set VLLSM = 0b01 */
    460            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(1);          
    461            /*wait for write to complete to SMC before stopping core */  
    462            dummyread = SMC_STOPCTRL;
    463            dummyread++;
    464            /* Now execute the stop instruction to go into VLLS1 */
    465            #ifdef CMSIS
    466            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    467            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    468            __wfi();
    469          #else
    470            stop();
    471          #endif
    472          }
    473          
    474          /********************************************************************/
    475          /* VLLS0 mode entry routine. Puts the processor into VLLS0 mode from
    476           * normal run mode or VLPR. 
    477           *
    478           * Mode transitions:
    479           * RUN -> VLLS0
    480           * VLPR -> VLLS0
    481           *
    482           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    483           * in VLPR mode before entering VLLSx.
    484           *
    485           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    486           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    487           * sure to setup the desired wakeup sources in the LLWU before 
    488           * calling this function.
    489           *
    490           * Parameters:
    491           * PORPO_value - 0 POR detect circuit is enabled in VLLS0
    492           *               1 POR detect circuit is disabled in VLLS0
    493           */
    494           /***************************************************************/
    495          
    496          void enter_vlls0(unsigned char PORPO_value )
    497          {
    498            int i;
    499            /* Write to PMPROT to allow all possible power modes */
    500            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;   
    501            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
    502               SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;   // go back to RUN mode temporarily
    503               for (i=0;i<0xff;i++)
    504                 {
    505                 if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
    506              	 break;
    507                 }
    508            }
    509            /* Set the STOPM field to 0b100 for VLLS0 mode */
    510            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
    511            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
    512            /* set VLLSM = 0b00 */
    513            SMC_STOPCTRL &= ~SMC_STOPCTRL_VLLSM_MASK;
    514            SMC_STOPCTRL &= ~SMC_STOPCTRL_PORPO_MASK;
    515            SMC_STOPCTRL |=  (PORPO_value <<SMC_STOPCTRL_PORPO_SHIFT) 
    516                           | SMC_STOPCTRL_VLLSM(0);          
    517            /*wait for write to complete to SMC before stopping core */  
    518            PORPO_value = SMC_STOPCTRL;
    519            /* Now execute the stop instruction to go into VLLS0 */
    520            #ifdef CMSIS
    521            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    522            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    523            __wfi();
    524          #else
    525            stop();
    526          #endif
    527          }
    528          /***************************************************************/
    529          /* VLLS0 mode entry routine. Puts the processor into VLLS0 mode from
    530           * normal run mode or VLPR with the POR circuit disabled
    531           *
    532           * Mode transitions:
    533           * RUN -> VLLS0
    534           * VLPR -> VLLS0
    535           *
    536           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    537           * in VLPR mode before entering VLLSx.
    538           *
    539           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    540           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    541           * sure to setup the desired wakeup sources in the LLWU before 
    542           * calling this function.
    543           *
    544           * Parameters:
    545           * PORPO = 1-  POR detect circuit is disabled in VLLS0
    546           */
    547          /***************************************************************/
    548          void enter_vlls0_nopor(void)
    549          {
    550            volatile unsigned int dummyread;
    551            int i;
    552            /* Write to PMPROT to allow all possible power modes */
    553            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;   
    554            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
    555               SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;   // go back to RUN mode temporarily
    556               for (i=0;i<0xff;i++)
    557                 {
    558                 if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
    559              	 break;
    560                 }
    561            }
    562            /* Set the STOPM field to 0b100 for VLLS0 mode */
    563            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
    564            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
    565            /* set VLLSM = 00 * and PORPO = 1 */
    566            SMC_STOPCTRL &= ~SMC_STOPCTRL_VLLSM_MASK;
    567            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(0) | SMC_STOPCTRL_PORPO_MASK;  
    568            /*wait for write to complete to SMC before stopping core */  
    569            dummyread = SMC_STOPCTRL;
    570            dummyread++;
    571            /* Now execute the stop instruction to go into VLLS0 */
    572            #ifdef CMSIS
    573            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    574            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    575            __wfi();
    576          #else
    577            stop();
    578          #endif
    579          }
    580          
    581          
    582          /********************************************************************/
    583          /********************End of Functions *******************************/
    584          /********************************************************************/
    585          
    586          
    587          

Errors: 2
Warnings: none
